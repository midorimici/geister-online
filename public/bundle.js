/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client.ts":
/*!***********************!*\
  !*** ./src/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw */ \"./src/draw.ts\");\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mouse */ \"./src/mouse.ts\");\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./piece */ \"./src/piece.ts\");\nvar __read = (undefined && undefined.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (undefined && undefined.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\n\r\n\r\n\r\n/** 言語が英語である */\r\nvar isEN = location.pathname === '/en/';\r\n// 入室～対戦相手待機\r\nvar draw;\r\n/** initCanvas を実行済か */\r\nvar doneInitCanvas = false;\r\n/** canvas 要素 */\r\nvar canvas = document.getElementById('canvas');\r\n/** canvas 横のメッセージ */\r\nvar gameMessage = document.getElementById('game-message');\r\n/** ミュートボタン */\r\nvar muteButton = document.getElementById('mute-icon');\r\n/** ミュート状態か */\r\nvar muted = true;\r\n/** 入力フォームを非表示にし、canvas などを表示する */\r\nvar initCanvas = function () {\r\n    document.getElementById('settings').style.display = 'none';\r\n    var cw = document.documentElement.clientWidth;\r\n    var ch = document.documentElement.clientHeight;\r\n    if (cw < ch || ch < 720) {\r\n        document.getElementById('logo').style.display = 'none';\r\n        document.getElementById('info-icon').style.display = 'none';\r\n        document.getElementsByTagName('footer')[0].style.display = 'none';\r\n    }\r\n    var min = cw < ch ? cw : ch;\r\n    var cvsize = (0.9 * min).toString();\r\n    canvas.setAttribute('width', cvsize);\r\n    canvas.setAttribute('height', cvsize);\r\n    draw = new _draw__WEBPACK_IMPORTED_MODULE_0__.default(canvas, isEN);\r\n    doneInitCanvas = true;\r\n    document.getElementById('game-container').style.display = 'flex';\r\n};\r\n/** 対戦者か観戦者か */\r\nvar myrole;\r\n// フォーム取得\r\n// production: https://geister-online.herokuapp.com\r\nvar socket = io();\r\nvar form = document.getElementById('form');\r\nform.addEventListener('submit', function (e) {\r\n    e.preventDefault();\r\n    var data = new FormData(form);\r\n    var info = {\r\n        roomId: data.get('room'),\r\n        role: data.get('role'),\r\n        name: data.get('username') === ''\r\n            ? (isEN ? 'anonymous' : '名無し')\r\n            : data.get('username'),\r\n    };\r\n    myrole = info.role;\r\n    socket.emit('enter room', info);\r\n}, false);\r\n// 部屋がいっぱいだったとき\r\nsocket.on('room full', /** @param id 部屋番号 */ function (id) {\r\n    var p = document.getElementById('message');\r\n    p.innerText = isEN\r\n        ? \"The room \" + id + \" is full. You cannot join in as a player.\"\r\n        : \"\\u30EB\\u30FC\\u30E0 \" + id + \" \\u306F\\u3044\\u3063\\u3071\\u3044\\u3067\\u3059\\u3002\\u5BFE\\u6226\\u8005\\u3068\\u3057\\u3066\\u53C2\\u52A0\\u3059\\u308B\\u3053\\u3068\\u306F\\u3067\\u304D\\u307E\\u305B\\u3093\\u3002\";\r\n});\r\n// 空室を観戦しようとしたとき\r\nsocket.on('no room', /** @param id 部屋番号 */ function (id) {\r\n    var p = document.getElementById('message');\r\n    p.innerText = isEN\r\n        ? \"No player is present in the room \" + id + \".\"\r\n        : \"\\u30EB\\u30FC\\u30E0 \" + id + \" \\u3067\\u306F\\u5BFE\\u6226\\u304C\\u884C\\u308F\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\\u3002\";\r\n});\r\n// 対戦相手を待っているとき\r\nsocket.on('wait opponent', function () {\r\n    if (!doneInitCanvas) {\r\n        initCanvas();\r\n    }\r\n    ;\r\n    draw.waitingPlayer();\r\n});\r\n// 駒配置\r\n/** 位置と色の Map */\r\nvar posmap = new Map();\r\nfor (var i = 1; i <= 4; i++) {\r\n    for (var j = 2; j <= 3; j++) {\r\n        posmap.set(i + \",\" + j, 'R');\r\n    }\r\n}\r\nvar mouse;\r\n/**\r\n * 音声を再生する\r\n * @param file ファイル名。拡張子除く\r\n */\r\nvar snd = function (file) {\r\n    new Audio(\"../static/sounds/\" + file + \".wav\").play();\r\n};\r\n// 駒を配置する処理\r\nsocket.on('place pieces', function () {\r\n    if (!doneInitCanvas) {\r\n        initCanvas();\r\n    }\r\n    ;\r\n    var csize = canvas.width;\r\n    /** 赤と青が同数ずつあるか */\r\n    var satisfied = false;\r\n    //const selectSnd = new Audio('../static/sounds/select.wav');\r\n    /**\r\n     * 赤と青が同数ずつあるかチェックする\r\n     * @param colors 色のリスト\r\n     */\r\n    var checkColor = function (colors) {\r\n        return (colors.filter(function (color) { return color === 'R'; })).length\r\n            === (colors.filter(function (color) { return color === 'B'; })).length;\r\n    };\r\n    /** 画面を描画する */\r\n    var drawDisp = function () {\r\n        draw.decidePiecePlace(posmap, !satisfied);\r\n    };\r\n    drawDisp();\r\n    // マウスイベント\r\n    mouse = new _mouse__WEBPACK_IMPORTED_MODULE_1__.default(canvas);\r\n    canvas.onclick = function (e) {\r\n        // 駒配置\r\n        for (var i = 1; i <= 4; i++) {\r\n            for (var j = 2; j <= 3; j++) {\r\n                if (String(mouse.getCoord(e)) === String([i, j])) {\r\n                    posmap.set(i + \",\" + j, posmap.get(i + \",\" + j) === 'R'\r\n                        ? 'B' : 'R');\r\n                    satisfied = checkColor(Array.from(posmap.values()));\r\n                    if (!muted)\r\n                        snd('select');\r\n                }\r\n            }\r\n        }\r\n        // ボタン\r\n        if (mouse.onArea.apply(mouse, __spread(mouse.getWindowPos(e), [csize * 5 / 6, csize * 5 / 6, csize / 8, csize / 12]))) {\r\n            if (satisfied) {\r\n                canvas.onclick = function () { };\r\n                socket.emit('decided place', __spread(posmap.entries()));\r\n                if (!muted)\r\n                    snd('decide');\r\n            }\r\n            else {\r\n                if (!muted)\r\n                    snd('forbid');\r\n            }\r\n        }\r\n        drawDisp();\r\n    };\r\n});\r\n// 駒の配置を待つ処理\r\nsocket.on('wait placing', function () {\r\n    if (!doneInitCanvas) {\r\n        initCanvas();\r\n    }\r\n    ;\r\n    draw.waitingPlacing();\r\n});\r\n// ゲーム進行\r\n// 対戦者の処理\r\nsocket.on('game', \r\n/**\r\n * 対戦者側のゲーム処理\r\n * @param board 盤面データ\r\n * @param turn 自分が先手か後手か\r\n * @param myturn 現在自分のターンか\r\n * @param first 先手のプレイヤー名\r\n * @param second 後手のプレイヤー名\r\n * @param takenPieces それぞれが取った駒の色と数\r\n */\r\nfunction (board, turn, myturn, first, second, takenPieces) {\r\n    var boardmap = new Map(board);\r\n    /** 選択中の駒の位置 */\r\n    var selectingPos;\r\n    draw.board(boardmap, turn, first, second);\r\n    draw.takenPieces(takenPieces, turn);\r\n    // 手番の表示\r\n    // マウスイベント\r\n    if (myturn) {\r\n        gameMessage.innerText = isEN ? \"It's your turn.\" : 'あなたの番です。';\r\n        if (!muted)\r\n            snd('move');\r\n        mouse = new _mouse__WEBPACK_IMPORTED_MODULE_1__.default(canvas);\r\n        canvas.onclick = function (e) {\r\n            var sqPos = mouse.getCoord(e);\r\n            if (boardmap.has(String(sqPos))\r\n                && boardmap.get(String(sqPos)).turn === turn) {\r\n                // 自分の駒を選択したとき\r\n                selectingPos = sqPos;\r\n                var pieceData = Object.values(boardmap.get(String(sqPos)));\r\n                var piece = new (_piece__WEBPACK_IMPORTED_MODULE_2__.default.bind.apply(_piece__WEBPACK_IMPORTED_MODULE_2__.default, __spread([void 0], pieceData)))();\r\n                // 行先を描画\r\n                draw.board(boardmap, turn, first, second);\r\n                draw.dest(piece, selectingPos, boardmap);\r\n                draw.takenPieces(takenPieces, turn);\r\n            }\r\n            else {\r\n                if (boardmap.has(String(selectingPos))) {\r\n                    var pieceData = Object.values(boardmap.get(String(selectingPos)));\r\n                    var piece = new (_piece__WEBPACK_IMPORTED_MODULE_2__.default.bind.apply(_piece__WEBPACK_IMPORTED_MODULE_2__.default, __spread([void 0], pieceData)))();\r\n                    if (piece.coveringSquares(selectingPos).some(function (e) {\r\n                        return String(e) === String(sqPos);\r\n                    })) {\r\n                        // 行先を選択したとき\r\n                        // 駒の移動\r\n                        boardmap.set(String(sqPos), boardmap.get(String(selectingPos)));\r\n                        boardmap.delete(String(selectingPos));\r\n                        if (!muted)\r\n                            snd('move');\r\n                        // サーバへ移動データを渡す\r\n                        socket.emit('move piece', turn, selectingPos, sqPos);\r\n                    }\r\n                }\r\n                // 盤面描画更新\r\n                draw.board(boardmap, turn, first, second);\r\n                draw.takenPieces(takenPieces, turn);\r\n                selectingPos = null;\r\n            }\r\n        };\r\n    }\r\n    else {\r\n        gameMessage.innerText = isEN ? \"It's your opponent's turn.\" : '相手の番です。';\r\n        canvas.onclick = function () { };\r\n    }\r\n});\r\n// 観戦者の処理\r\nsocket.on('watch', \r\n/**\r\n * 観戦者側のゲーム処理\r\n * @param board 盤面データ\r\n * @param first 先手のプレイヤー名\r\n * @param second 後手のプレイヤー名\r\n * @param turn 現在のターン\r\n * @param takenPieces それぞれが取った駒の色と数\r\n */\r\nfunction (board, first, second, turn, takenPieces) {\r\n    if (myrole === 'watch') {\r\n        if (!doneInitCanvas) {\r\n            initCanvas();\r\n        }\r\n        ;\r\n        var boardmap = new Map(board);\r\n        draw.board(boardmap, 0, first, second, true);\r\n        draw.takenPieces(takenPieces, 0);\r\n        var curPlayer = turn === 0 ? first : second;\r\n        gameMessage.innerText = isEN\r\n            ? \"It's \" + curPlayer + \"'s turn.\"\r\n            : curPlayer + \" \\u3055\\u3093\\u306E\\u756A\\u3067\\u3059\\u3002\";\r\n        if (!muted)\r\n            snd('move');\r\n    }\r\n});\r\n// 勝者が決まったとき（観戦者と先手）\r\nsocket.on('tell winner to audience and first', \r\n/** 勝者が決まったときの処理\r\n * @param winner 勝者のプレイヤー名\r\n * @param board 盤面データ\r\n * @param first 先手のプレイヤー名\r\n * @param second 後手のプレイヤー名\r\n * @param takenPieces それぞれが取った駒の色と数\r\n*/\r\nfunction (winner, board, first, second, takenPieces) {\r\n    gameMessage.innerText = isEN ? winner + \" won!\" : winner + \" \\u306E\\u52DD\\u3061\\uFF01\";\r\n    if (!muted)\r\n        snd('win');\r\n    if (myrole === 'play') {\r\n        canvas.onclick = function () {\r\n            draw.board(new Map(board), 0, first, second, true);\r\n            draw.takenPieces(takenPieces, 0);\r\n            canvas.onclick = function () { };\r\n        };\r\n    }\r\n});\r\n// 勝者が決まったとき（後手）\r\nsocket.on('tell winner to second', \r\n/** 勝者が決まったときの処理\r\n * @param winner 勝者のプレイヤー名\r\n * @param board 盤面データ\r\n * @param first 先手のプレイヤー名\r\n * @param second 後手のプレイヤー名\r\n * @param takenPieces それぞれが取った駒の色と数\r\n*/\r\nfunction (winner, board, first, second, takenPieces) {\r\n    gameMessage.innerText = isEN ? winner + \" won!\" : winner + \" \\u306E\\u52DD\\u3061\\uFF01\";\r\n    if (!muted)\r\n        snd('win');\r\n    canvas.onclick = function () {\r\n        draw.board(new Map(board), 1, first, second, true);\r\n        draw.takenPieces(takenPieces, 1);\r\n        canvas.onclick = function () { };\r\n    };\r\n});\r\n// 接続が切れたとき\r\nsocket.on('player discon', \r\n/** @param name 接続が切れたプレイヤー名 */ function (name) {\r\n    alert(isEN\r\n        ? name + \"'s connection is closed.\"\r\n        : name + \" \\u3055\\u3093\\u306E\\u63A5\\u7D9A\\u304C\\u5207\\u308C\\u307E\\u3057\\u305F\\u3002\");\r\n    location.reload();\r\n});\r\n// ミュートボタン\r\nmuteButton.onclick = function () {\r\n    muteButton.src = muted\r\n        ? '../static/svg/volume-up-solid.svg'\r\n        : '../static/svg/volume-mute-solid.svg';\r\n    muteButton.title = muted\r\n        ? (isEN ? 'Mute' : 'ミュート')\r\n        : (isEN ? 'Unmute' : 'ミュート解除');\r\n    muted = !muted;\r\n};\r\n// チャット\r\nvar chatForm = document.getElementById('chat-form');\r\nvar chatInput = document.getElementById('chat-input');\r\nvar chatSendButton = document.getElementById('chat-send-icon');\r\nchatForm.addEventListener('submit', function (e) {\r\n    e.preventDefault();\r\n    if (chatInput.value) {\r\n        socket.emit('chat message', chatInput.value);\r\n        chatInput.value = '';\r\n    }\r\n});\r\nchatSendButton.onclick = function () {\r\n    if (chatInput.value) {\r\n        socket.emit('chat message', chatInput.value);\r\n        chatInput.value = '';\r\n    }\r\n};\r\nvar ul = document.getElementById('chat-messages');\r\nsocket.on('chat message', \r\n/**\r\n * チャット受信の処理\r\n * @param msg 入力されたメッセージ\r\n * @param isPlayer 入力した人が対戦者か\r\n * @param name 入力した人の名前\r\n */\r\nfunction (msg, isPlayer, name) {\r\n    var item = document.createElement('li');\r\n    var nameSpan = document.createElement('span');\r\n    nameSpan.className = 'chat-name';\r\n    nameSpan.innerText = name;\r\n    if (isPlayer) {\r\n        var icon = document.createElement('img');\r\n        icon.className = 'chat-player-icon';\r\n        icon.src = '../static/svg/ghost-solid.svg';\r\n        icon.alt = 'player-icon';\r\n        icon.title = isEN ? 'Player' : '対戦者';\r\n        nameSpan.appendChild(icon);\r\n    }\r\n    item.appendChild(nameSpan);\r\n    var msgSpan = document.createElement('span');\r\n    msgSpan.innerText = msg;\r\n    item.appendChild(msgSpan);\r\n    ul.appendChild(item);\r\n    ul.scrollTop = ul.scrollHeight;\r\n});\r\n// info ボタン\r\nvar infoBtn = document.getElementById('info-icon');\r\ninfoBtn.onclick = function () {\r\n    document.getElementById('info-overlay').style.display = 'flex';\r\n};\r\nvar infoCloseBtn = document.getElementById('close-icon');\r\ninfoCloseBtn.onclick = function () {\r\n    document.getElementById('info-overlay').style.display = 'none';\r\n};\r\n\n\n//# sourceURL=webpack://geister-online/./src/client.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__,\n/* harmony export */   \"Vec\": () => /* binding */ Vec\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n    ivory: 'rgb(240, 227, 206)',\r\n    dark: 'rgb(30, 30, 30)',\r\n    red: 'rgb(200, 0, 0)',\r\n    blue: 'rgb(0, 0, 200)',\r\n    grey: 'rgb(150, 150, 150)',\r\n    safe: 'rgb(121, 202, 68)'\r\n});\r\n/**\r\n * @classdesc 二次元ベクトルの計算を補助する\r\n */\r\nvar Vec = /** @class */ (function () {\r\n    /**\r\n     * @param v 二数の配列\r\n     */\r\n    function Vec(v) {\r\n        this.v = v;\r\n    }\r\n    /**\r\n     * Vec インスタンスから二数の配列を返す\r\n     */\r\n    Vec.prototype.val = function () {\r\n        return this.v;\r\n    };\r\n    /**\r\n     * ベクトルに加算する\r\n     * @param v 加算する数またはベクトル\r\n     */\r\n    Vec.prototype.add = function (v) {\r\n        if (Array.isArray(v)) {\r\n            return new Vec([v[0] + this.v[0], v[1] + this.v[1]]);\r\n        }\r\n        else {\r\n            return new Vec([v + this.v[0], v + this.v[1]]);\r\n        }\r\n    };\r\n    /**\r\n     * ベクトルに乗算する\r\n     * @param n 乗ずる数\r\n     */\r\n    Vec.prototype.mul = function (n) {\r\n        return new Vec([n * this.v[0], n * this.v[1]]);\r\n    };\r\n    /**\r\n     * ベクトルに除算する\r\n     * @param n 除する数\r\n     */\r\n    Vec.prototype.div = function (n) {\r\n        return new Vec([this.v[0] / n, this.v[1] / n]);\r\n    };\r\n    /**\r\n     * ベクトルに除算した商を返す\r\n     * @param n 除する数\r\n     */\r\n    Vec.prototype.quot = function (n) {\r\n        return new Vec([Math.floor(this.v[0] / n), Math.floor(this.v[1] / n)]);\r\n    };\r\n    return Vec;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://geister-online/./src/config.ts?");

/***/ }),

/***/ "./src/draw.ts":
/*!*********************!*\
  !*** ./src/draw.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\nvar __read = (undefined && undefined.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spread = (undefined && undefined.__spread) || function () {\r\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n};\r\nvar __values = (undefined && undefined.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\n\r\nvar Draw = /** @class */ (function () {\r\n    /**\r\n     * - canvas サイズ設定\r\n     * - context 作成\r\n     * - プロパティ定義\r\n     * - 駒、矢印のパス定義\r\n     * @param canvas canvas 要素\r\n     */\r\n    function Draw(canvas, isEN) {\r\n        this.canvas = canvas;\r\n        this.isEN = isEN;\r\n        this.ctx = canvas.getContext('2d');\r\n        this.squareSize = canvas.width * 3 / 20;\r\n        this.margin = canvas.width / 20;\r\n        this.pieceSize = canvas.width / 10;\r\n        this.piecePath = new Path2D();\r\n        this.piecePath.moveTo(0, -this.pieceSize / 2);\r\n        this.piecePath.lineTo(-this.pieceSize / 2, this.pieceSize / 2);\r\n        this.piecePath.lineTo(this.pieceSize / 2, this.pieceSize / 2);\r\n        this.piecePath.closePath();\r\n        this.arrowPath = new Path2D();\r\n        this.arrowPath.moveTo(this.pieceSize / 2, this.pieceSize / 2);\r\n        this.arrowPath.lineTo(0, 0);\r\n        this.arrowPath.lineTo(-this.pieceSize / 2, this.pieceSize / 2);\r\n        this.arrowPath.moveTo(0, 0);\r\n        this.arrowPath.lineTo(0, this.pieceSize);\r\n        this.arrowPath.closePath();\r\n    }\r\n    /** アイボリーで画面全体を塗りつぶす */\r\n    Draw.prototype.clearCanvas = function () {\r\n        this.ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.default.ivory;\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    };\r\n    /** 待機画面\r\n     * @param obj 待機している対象。\r\n     * 対戦者の入室または対戦者の駒配置\r\n     */\r\n    Draw.prototype.waiting = function (obj) {\r\n        this.clearCanvas();\r\n        var canvas = this.canvas;\r\n        var ctx = this.ctx;\r\n        var textSize = canvas.width / 20;\r\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.default.dark;\r\n        ctx.font = textSize + \"px Meiryo\";\r\n        if (obj === 'player') {\r\n            ctx.fillText(this.isEN\r\n                ? 'Waiting for the opponent...'\r\n                : '対戦相手の入室を待っています...', canvas.width / 2 - (7.5) * textSize, canvas.height / 2);\r\n        }\r\n        else {\r\n            ctx.fillText(this.isEN\r\n                ? 'Waiting for players placing pieces...'\r\n                : '対戦者が駒を配置するのを待っています...', canvas.width / 2 - (9.5) * textSize, canvas.height / 2);\r\n        }\r\n    };\r\n    /** 対戦相手の参加を待つ画面 */\r\n    Draw.prototype.waitingPlayer = function () {\r\n        this.waiting('player');\r\n    };\r\n    /** 対戦者の駒配置を待つ画面（観戦者のみ） */\r\n    Draw.prototype.waitingPlacing = function () {\r\n        this.waiting('placing');\r\n    };\r\n    /**\r\n     * 一辺 squareSize のグリッドを描く\r\n     * @param coord 左上の座標。ウィンドウ座標\r\n     * @param col 列数\r\n     * @param row 行数\r\n     */\r\n    Draw.prototype.grid = function (coord, col, row) {\r\n        var ctx = this.ctx;\r\n        var squareSize = this.squareSize;\r\n        ctx.strokeStyle = _config__WEBPACK_IMPORTED_MODULE_0__.default.dark;\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        for (var i = 0; i <= row; i++) {\r\n            ctx.moveTo.apply(ctx, __spread(new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(coord).add([0, squareSize * i]).val()));\r\n            ctx.lineTo.apply(ctx, __spread(new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(coord).add([squareSize * col, squareSize * i]).val()));\r\n        }\r\n        for (var i = 0; i <= col; i++) {\r\n            ctx.moveTo.apply(ctx, __spread(new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(coord).add([squareSize * i, 0]).val()));\r\n            ctx.lineTo.apply(ctx, __spread(new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(coord).add([squareSize * i, squareSize * row]).val()));\r\n        }\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    };\r\n    /**\r\n     * 駒を描く\r\n     * @param color 駒色。rgb(R, G, B) の書式\r\n     * @param pos 駒の位置。ゲーム内座標\r\n     * @param rev 上下反転して表示する\r\n     */\r\n    Draw.prototype.piece = function (color, pos, rev) {\r\n        var ctx = this.ctx;\r\n        var coord = new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).mul(this.squareSize)\r\n            .add(this.margin + this.squareSize / 2).val();\r\n        ctx.save();\r\n        ctx.fillStyle = color;\r\n        ctx.translate.apply(ctx, __spread(coord));\r\n        if (rev) {\r\n            // 相手の駒は逆転して描く\r\n            ctx.rotate(Math.PI);\r\n        }\r\n        ctx.fill(this.piecePath);\r\n        ctx.restore();\r\n    };\r\n    /**\r\n     * ボタンを描く\r\n     * @param coord 位置。ウィンドウ座標\r\n     * @param size 幅と高さ\r\n     * @param disabled 押せなくする\r\n     */\r\n    Draw.prototype.button = function (coord, size, disabled) {\r\n        var ctx = this.ctx;\r\n        ctx.fillStyle = disabled ?\r\n            'rgb(160, 140, 120)' : 'rgb(200, 180, 160)';\r\n        ctx.fillRect.apply(ctx, __spread(coord, size));\r\n        ctx.font = this.canvas.width / 30 + \"px Meiryo\";\r\n        ctx.save();\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.default.dark;\r\n        ctx.fillText.apply(ctx, __spread(['OK'], new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(size).div(2).add(coord).val()));\r\n        ctx.restore();\r\n    };\r\n    /** 駒の配置を決める画面（対戦者のみ）\r\n     * @param pos 位置と色の Map\r\n     * @param disabled ボタンを押せなくする\r\n    */\r\n    Draw.prototype.decidePiecePlace = function (pos, disabled) {\r\n        var e_1, _a;\r\n        this.clearCanvas();\r\n        var ctx = this.ctx;\r\n        var csize = this.canvas.width;\r\n        var textSize = csize / 40;\r\n        var text1 = this.isEN\r\n            ? \"Decide the initial positions of your pieces. (↓ your side   ↑ opponent's side)\"\r\n            : '駒の配置を決めてね（↓自分側　↑相手側）';\r\n        var text2 = this.isEN\r\n            ? 'Click (tap) the pieces to swap bad ghosts (red) and good ghosts (blue).'\r\n            : 'クリック（タップ）で悪いおばけ（赤）と良いおばけ（青）を切り替えるよ';\r\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.default.dark;\r\n        ctx.font = textSize + \"px Meiryo\";\r\n        ctx.fillText(text1, csize / 30, csize / 30);\r\n        ctx.fillText(text2, csize / 30, csize / 30 + 2 * textSize);\r\n        var lefttop = [\r\n            this.margin + this.squareSize,\r\n            this.margin + 2 * this.squareSize\r\n        ];\r\n        this.grid(lefttop, 4, 2);\r\n        this.button([csize * 5 / 6, csize * 5 / 6], [csize / 8, csize / 12], disabled);\r\n        try {\r\n            for (var _b = __values(pos.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), k = _d[0], v = _d[1];\r\n                var _e = __read(k.split(','), 2), x = _e[0], y = _e[1];\r\n                this.piece(v === 'R' ? _config__WEBPACK_IMPORTED_MODULE_0__.default.red : _config__WEBPACK_IMPORTED_MODULE_0__.default.blue, [+x, +y], false);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    /** ゲームボードと盤面上の駒を描く\r\n     * @param boardmap 盤面データ\r\n     * @param turn 先手後手どちら目線か\r\n     * @param first 先手のプレイヤー名\r\n     * @param second 後手のプレイヤー名\r\n     * @param showAll すべての駒色を隠さず表示する\r\n     */\r\n    Draw.prototype.board = function (boardmap, turn, first, second, showAll) {\r\n        var e_2, _a;\r\n        if (showAll === void 0) { showAll = false; }\r\n        this.clearCanvas();\r\n        var ctx = this.ctx;\r\n        // グリッド\r\n        this.grid([this.margin, this.margin], 6, 6);\r\n        // 角の矢印\r\n        var padding = (this.squareSize - this.pieceSize) / 2;\r\n        var coord = new _config__WEBPACK_IMPORTED_MODULE_0__.Vec([this.squareSize / 2, padding])\r\n            .add(this.margin).val();\r\n        ctx.save();\r\n        ctx.translate.apply(ctx, __spread(coord));\r\n        ctx.stroke(this.arrowPath);\r\n        ctx.restore();\r\n        ctx.save();\r\n        ctx.translate.apply(ctx, __spread(new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(coord).add([5 * this.squareSize, 0]).val()));\r\n        ctx.stroke(this.arrowPath);\r\n        ctx.restore();\r\n        ctx.save();\r\n        ctx.translate.apply(ctx, __spread(new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(coord)\r\n            .add([0, 5 * this.squareSize + this.pieceSize]).val()));\r\n        ctx.rotate(Math.PI);\r\n        ctx.stroke(this.arrowPath);\r\n        ctx.restore();\r\n        ctx.save();\r\n        ctx.translate.apply(ctx, __spread(new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(coord)\r\n            .add([5 * this.squareSize,\r\n            5 * this.squareSize + this.pieceSize]).val()));\r\n        ctx.rotate(Math.PI);\r\n        ctx.stroke(this.arrowPath);\r\n        ctx.restore();\r\n        try {\r\n            // 駒\r\n            for (var _b = __values(boardmap.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), pos = _d[0], piece = _d[1];\r\n                var pieceColor = piece.color === 'R' ? _config__WEBPACK_IMPORTED_MODULE_0__.default.red : _config__WEBPACK_IMPORTED_MODULE_0__.default.blue;\r\n                var pos_ = pos.split(',').map(function (e) { return +e; });\r\n                if (turn === 0) {\r\n                    // 先手\r\n                    this.piece((showAll || piece.turn === 0) ? pieceColor : _config__WEBPACK_IMPORTED_MODULE_0__.default.grey, pos_, piece.turn === 1);\r\n                }\r\n                else {\r\n                    // 後手\r\n                    this.piece((showAll || piece.turn === 1) ? pieceColor : _config__WEBPACK_IMPORTED_MODULE_0__.default.grey, pos_, piece.turn === 0);\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        // プレイヤー名\r\n        var csize = this.canvas.width;\r\n        var textSize = csize / 40;\r\n        ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.default.dark;\r\n        ctx.font = textSize + \"px Meiryo\";\r\n        ctx.fillText(turn === 1 ? second : first, csize * 3 / 4, csize - textSize);\r\n        ctx.fillText(turn === 1 ? first : second, csize * 3 / 4, textSize);\r\n    };\r\n    /**\r\n     * 駒の行先を円で表示する\r\n     * @param piece 駒インスタンス\r\n     * @param pos 位置。ゲーム内座標\r\n     * @param boardmap 盤面データ\r\n     */\r\n    Draw.prototype.dest = function (piece, pos, boardmap) {\r\n        var e_3, _a;\r\n        var ctx = this.ctx;\r\n        try {\r\n            for (var _b = __values(piece.coveringSquares(pos)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var dest = _c.value;\r\n                // 自分の駒の位置を除外\r\n                if (!(boardmap.has(String(dest))\r\n                    && boardmap.get(String(dest)).turn\r\n                        === boardmap.get(String(pos)).turn)) {\r\n                    var coord = new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(dest).mul(this.squareSize)\r\n                        .add(this.margin + this.squareSize / 2).val();\r\n                    ctx.beginPath();\r\n                    ctx.arc.apply(ctx, __spread(coord, [this.pieceSize / 2, 0, 2 * Math.PI]));\r\n                    ctx.fillStyle = _config__WEBPACK_IMPORTED_MODULE_0__.default.safe;\r\n                    ctx.fill();\r\n                }\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    /**\r\n     * 取った駒を盤面の端に描画する\r\n     * @param numbers それぞれが取った駒の色と数\r\n     * @param turn 先手後手どちら目線か\r\n     */\r\n    Draw.prototype.takenPieces = function (numbers, turn) {\r\n        var _this = this;\r\n        var ctx = this.ctx;\r\n        var smallPieceSize = this.pieceSize / 6;\r\n        var margin = this.margin;\r\n        var squareSize = this.squareSize;\r\n        var drawPiece = function (coord, color) {\r\n            ctx.save();\r\n            ctx.fillStyle = color;\r\n            ctx.translate.apply(ctx, __spread(coord));\r\n            ctx.scale(1 / 6, 1 / 6);\r\n            ctx.fill(_this.piecePath);\r\n            ctx.restore();\r\n        };\r\n        var y1 = turn === 0 ? margin + 6 * squareSize + smallPieceSize : smallPieceSize;\r\n        var y2 = turn === 1 ? margin + 6 * squareSize + smallPieceSize : smallPieceSize;\r\n        // 先手が取った駒\r\n        for (var i = 0; i < numbers[0]['R']; i++) {\r\n            var coord = [(i + 1) * smallPieceSize, y1];\r\n            drawPiece(coord, _config__WEBPACK_IMPORTED_MODULE_0__.default.red);\r\n        }\r\n        for (var i = 0; i < numbers[0]['B']; i++) {\r\n            var coord = [(i + 1 + numbers[0]['R']) * smallPieceSize, y1];\r\n            drawPiece(coord, _config__WEBPACK_IMPORTED_MODULE_0__.default.blue);\r\n        }\r\n        // 後手が取った駒\r\n        for (var i = 0; i < numbers[1]['R']; i++) {\r\n            var coord = [(i + 1) * smallPieceSize, y2];\r\n            drawPiece(coord, _config__WEBPACK_IMPORTED_MODULE_0__.default.red);\r\n        }\r\n        for (var i = 0; i < numbers[1]['B']; i++) {\r\n            var coord = [(i + 1 + numbers[1]['R']) * smallPieceSize, y2];\r\n            drawPiece(coord, _config__WEBPACK_IMPORTED_MODULE_0__.default.blue);\r\n        }\r\n    };\r\n    return Draw;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Draw);\r\n;\r\n\n\n//# sourceURL=webpack://geister-online/./src/draw.ts?");

/***/ }),

/***/ "./src/mouse.ts":
/*!**********************!*\
  !*** ./src/mouse.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n\r\nvar Mouse = /** @class */ (function () {\r\n    function Mouse(canvas) {\r\n        this.squareSize = canvas.width * 3 / 20;\r\n        this.margin = canvas.width / 20;\r\n    }\r\n    /**\r\n     * ウィンドウ座標を取得する\r\n     * @param e マウスイベント\r\n     */\r\n    Mouse.prototype.getWindowPos = function (e) {\r\n        var rect = e.target.getBoundingClientRect();\r\n        return [e.clientX - rect.left, e.clientY - rect.top];\r\n    };\r\n    /**\r\n     * ウィンドウ座標をゲーム内座標に変換する\r\n     * @param pos ウィンドウ座標\r\n     */\r\n    Mouse.prototype.chcoord = function (pos) {\r\n        return new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos)\r\n            .add(-this.margin).quot(this.squareSize).val();\r\n    };\r\n    /**\r\n     * ゲーム内座標を取得する\r\n     * @param e マウスイベント\r\n     */\r\n    Mouse.prototype.getCoord = function (e) {\r\n        return this.chcoord(this.getWindowPos(e));\r\n    };\r\n    /**\r\n     * (x, y) が指定範囲内にあるか\r\n     * @param x 位置\r\n     * @param y 位置\r\n     * @param left 左端\r\n     * @param top 上端\r\n     * @param w 幅\r\n     * @param h 高さ\r\n     */\r\n    Mouse.prototype.onArea = function (x, y, left, top, w, h) {\r\n        return left <= x && x <= left + w && top <= y && y <= top + h;\r\n    };\r\n    return Mouse;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Mouse);\r\n\n\n//# sourceURL=webpack://geister-online/./src/mouse.ts?");

/***/ }),

/***/ "./src/piece.ts":
/*!**********************!*\
  !*** ./src/piece.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\nvar __read = (undefined && undefined.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\n\r\nvar Piece = /** @class */ (function () {\r\n    /**\r\n     * @param color 駒色\r\n     * @param turn 先手(0)後手(1)どちらの駒か\r\n     */\r\n    function Piece(color, turn) {\r\n        this.color = color;\r\n        this.turn = turn;\r\n    }\r\n    /**\r\n     * 駒が動ける位置のリストを返す\r\n     * @param pos 駒の位置。ゲーム内座標\r\n     */\r\n    Piece.prototype.coveringSquares = function (pos) {\r\n        var pos_ = [[0, 1], [0, -1], [-1, 0], [1, 0]]\r\n            .map(function (e) { return new _config__WEBPACK_IMPORTED_MODULE_0__.Vec(pos).add(e).val(); });\r\n        var dest = pos_\r\n            .filter(function (_a) {\r\n            var _b = __read(_a, 2), x = _b[0], y = _b[1];\r\n            return 0 <= x && x <= 5 && 0 <= y && y <= 5;\r\n        });\r\n        if (this.color === 'B') {\r\n            if (String(pos) === '0,0') {\r\n                dest.push([0, -1]);\r\n            }\r\n            else if (String(pos) === '5,0') {\r\n                dest.push([5, -1]);\r\n            }\r\n        }\r\n        return dest;\r\n    };\r\n    return Piece;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Piece);\r\n\n\n//# sourceURL=webpack://geister-online/./src/piece.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/client.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;